/*
 * Theta Lake API
 *
 * We are excited to inform you that our documentation is interactive!  If you are logged in, this means that you can not only read about the features and capabilities of our product, but also try them out directly from the documentation pages. Our interactive documentation provides a hands-on experience that allows you to test the API endpoints, experiment with the input parameters, and see the corresponding responses. This makes it easier to understand how the API works and how to integrate it into your own applications. With interactive documentation, you can save time and avoid frustration by testing the API right from the documentation pages, without having to set up a local development environment. Whether you're a seasoned developer or just starting out, our interactive documentation is the perfect tool to help you learn, experiment, and succeed with our API. 
 *
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Client.Auth;
using Org.OpenAPITools.Model;

namespace Org.OpenAPITools.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IDataIngestionApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Check data already exists
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;light&#x60;   **NOTE:** This endpoint supports searching for multiple datums. Because of this behavior it will never return a 404 Not Found, but instead just a blank response array.   Depending on the datum type (audio, chat, document, email, other, or video) different fields are returned. Fields that are always returned are denoted with a &#39;*&#39;.   Only 1 identifier can be specified, if both are specified, only &#x60;identity_data&#x60; will be checked 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identityData">The arbitrary string identifier data associated with the record. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="hashSha256">The sha256 hash of the record to check. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GetDatumIdentityResponse</returns>
        GetDatumIdentityResponse IngestionExistsGet(List<string>? identityData = default(List<string>?), List<string>? hashSha256 = default(List<string>?), int operationIndex = 0);

        /// <summary>
        /// Check data already exists
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;light&#x60;   **NOTE:** This endpoint supports searching for multiple datums. Because of this behavior it will never return a 404 Not Found, but instead just a blank response array.   Depending on the datum type (audio, chat, document, email, other, or video) different fields are returned. Fields that are always returned are denoted with a &#39;*&#39;.   Only 1 identifier can be specified, if both are specified, only &#x60;identity_data&#x60; will be checked 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identityData">The arbitrary string identifier data associated with the record. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="hashSha256">The sha256 hash of the record to check. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GetDatumIdentityResponse</returns>
        ApiResponse<GetDatumIdentityResponse> IngestionExistsGetWithHttpInfo(List<string>? identityData = default(List<string>?), List<string>? hashSha256 = default(List<string>?), int operationIndex = 0);
        /// <summary>
        /// Upload audio
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the audio should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no audio file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no audio file is attached, must **NOT** be set if there is an audio file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The audio to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostDatumResponse</returns>
        PostDatumResponse IngestionIntegrationIdAudioPost(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostAudioBodyMeta? meta = default(PostAudioBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0);

        /// <summary>
        /// Upload audio
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the audio should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no audio file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no audio file is attached, must **NOT** be set if there is an audio file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The audio to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostDatumResponse</returns>
        ApiResponse<PostDatumResponse> IngestionIntegrationIdAudioPostWithHttpInfo(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostAudioBodyMeta? meta = default(PostAudioBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0);
        /// <summary>
        /// Upload chats
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** This endpoint performs the upload of the chat data, image attachments, and file attachments.           The response contains upload responses for the chat data which includes the image attachments            and for the file attachments. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the chat conversation should be uploaded</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="chat"> (optional)</param>
        /// <param name="attachments">The actual attachment files from the chat messages (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostChatResponse</returns>
        PostChatResponse IngestionIntegrationIdChatPost(int id, PostChatConversationBodyMeta? meta = default(PostChatConversationBodyMeta?), PostChatConversationBodyChat? chat = default(PostChatConversationBodyChat?), List<System.IO.Stream>? attachments = default(List<System.IO.Stream>?), int operationIndex = 0);

        /// <summary>
        /// Upload chats
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** This endpoint performs the upload of the chat data, image attachments, and file attachments.           The response contains upload responses for the chat data which includes the image attachments            and for the file attachments. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the chat conversation should be uploaded</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="chat"> (optional)</param>
        /// <param name="attachments">The actual attachment files from the chat messages (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostChatResponse</returns>
        ApiResponse<PostChatResponse> IngestionIntegrationIdChatPostWithHttpInfo(int id, PostChatConversationBodyMeta? meta = default(PostChatConversationBodyMeta?), PostChatConversationBodyChat? chat = default(PostChatConversationBodyChat?), List<System.IO.Stream>? attachments = default(List<System.IO.Stream>?), int operationIndex = 0);
        /// <summary>
        /// Upload documents
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the document should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The document to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostDatumResponse</returns>
        PostDatumResponse IngestionIntegrationIdDocumentPost(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDocumentBodyMeta? meta = default(PostDocumentBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0);

        /// <summary>
        /// Upload documents
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the document should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The document to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostDatumResponse</returns>
        ApiResponse<PostDatumResponse> IngestionIntegrationIdDocumentPostWithHttpInfo(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDocumentBodyMeta? meta = default(PostDocumentBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0);
        /// <summary>
        /// Upload emails
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The &#x60;Content-Type&#x60; of the data part must be &#x60;message/rfc822&#x60;. Participant metadata should not be included in the JSON meta payload as it is parsed directly from the attached EML file. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostDatumResponse</returns>
        PostDatumResponse IngestionIntegrationIdEmailPost(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostEmailBodyMeta? meta = default(PostEmailBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0);

        /// <summary>
        /// Upload emails
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The &#x60;Content-Type&#x60; of the data part must be &#x60;message/rfc822&#x60;. Participant metadata should not be included in the JSON meta payload as it is parsed directly from the attached EML file. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostDatumResponse</returns>
        ApiResponse<PostDatumResponse> IngestionIntegrationIdEmailPostWithHttpInfo(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostEmailBodyMeta? meta = default(PostEmailBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0);
        /// <summary>
        /// Upload other data
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostDatumResponse</returns>
        PostDatumResponse IngestionIntegrationIdOtherPost(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDatumBodyMeta? meta = default(PostDatumBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0);

        /// <summary>
        /// Upload other data
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostDatumResponse</returns>
        ApiResponse<PostDatumResponse> IngestionIntegrationIdOtherPostWithHttpInfo(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDatumBodyMeta? meta = default(PostDatumBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0);
        /// <summary>
        /// Get integration state
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GetIntegrationStateResponse</returns>
        GetIntegrationStateResponse IngestionIntegrationIdStateGet(int id, int operationIndex = 0);

        /// <summary>
        /// Get integration state
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GetIntegrationStateResponse</returns>
        ApiResponse<GetIntegrationStateResponse> IngestionIntegrationIdStateGetWithHttpInfo(int id, int operationIndex = 0);
        /// <summary>
        /// Update integration state
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:update&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to update</param>
        /// <param name="putIntegrationStateRequest">The integration state to set</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GetIntegrationStateResponse</returns>
        GetIntegrationStateResponse IngestionIntegrationIdStatePut(int id, PutIntegrationStateRequest putIntegrationStateRequest, int operationIndex = 0);

        /// <summary>
        /// Update integration state
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:update&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to update</param>
        /// <param name="putIntegrationStateRequest">The integration state to set</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GetIntegrationStateResponse</returns>
        ApiResponse<GetIntegrationStateResponse> IngestionIntegrationIdStatePutWithHttpInfo(int id, PutIntegrationStateRequest putIntegrationStateRequest, int operationIndex = 0);
        /// <summary>
        /// Upload videos
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the video should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no video file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no video file is attached, must **NOT** be set if there is an video file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The video to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostDatumResponse</returns>
        PostDatumResponse IngestionIntegrationIdVideoPost(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostVideoBodyMeta? meta = default(PostVideoBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0);

        /// <summary>
        /// Upload videos
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the video should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no video file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no video file is attached, must **NOT** be set if there is an video file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The video to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostDatumResponse</returns>
        ApiResponse<PostDatumResponse> IngestionIntegrationIdVideoPostWithHttpInfo(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostVideoBodyMeta? meta = default(PostVideoBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0);
        /// <summary>
        /// Get upload quota
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The quota is for the entire org unit 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">A date in YYYY-MM-DD format that is the start of the time range to summarize in, if not provided the summary starts at the beginning of time (optional)</param>
        /// <param name="to">A date in YYY_MM_DD format that is the end of the time range to summarize, if not provided the summary ends with the current day (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>QuotaResponse</returns>
        QuotaResponse IngestionQuotaGet(string? from = default(string?), string? to = default(string?), int operationIndex = 0);

        /// <summary>
        /// Get upload quota
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The quota is for the entire org unit 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">A date in YYYY-MM-DD format that is the start of the time range to summarize in, if not provided the summary starts at the beginning of time (optional)</param>
        /// <param name="to">A date in YYY_MM_DD format that is the end of the time range to summarize, if not provided the summary ends with the current day (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of QuotaResponse</returns>
        ApiResponse<QuotaResponse> IngestionQuotaGetWithHttpInfo(string? from = default(string?), string? to = default(string?), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IDataIngestionApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Check data already exists
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;light&#x60;   **NOTE:** This endpoint supports searching for multiple datums. Because of this behavior it will never return a 404 Not Found, but instead just a blank response array.   Depending on the datum type (audio, chat, document, email, other, or video) different fields are returned. Fields that are always returned are denoted with a &#39;*&#39;.   Only 1 identifier can be specified, if both are specified, only &#x60;identity_data&#x60; will be checked 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identityData">The arbitrary string identifier data associated with the record. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="hashSha256">The sha256 hash of the record to check. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetDatumIdentityResponse</returns>
        System.Threading.Tasks.Task<GetDatumIdentityResponse> IngestionExistsGetAsync(List<string>? identityData = default(List<string>?), List<string>? hashSha256 = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Check data already exists
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;light&#x60;   **NOTE:** This endpoint supports searching for multiple datums. Because of this behavior it will never return a 404 Not Found, but instead just a blank response array.   Depending on the datum type (audio, chat, document, email, other, or video) different fields are returned. Fields that are always returned are denoted with a &#39;*&#39;.   Only 1 identifier can be specified, if both are specified, only &#x60;identity_data&#x60; will be checked 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identityData">The arbitrary string identifier data associated with the record. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="hashSha256">The sha256 hash of the record to check. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetDatumIdentityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetDatumIdentityResponse>> IngestionExistsGetWithHttpInfoAsync(List<string>? identityData = default(List<string>?), List<string>? hashSha256 = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Upload audio
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the audio should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no audio file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no audio file is attached, must **NOT** be set if there is an audio file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The audio to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostDatumResponse</returns>
        System.Threading.Tasks.Task<PostDatumResponse> IngestionIntegrationIdAudioPostAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostAudioBodyMeta? meta = default(PostAudioBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Upload audio
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the audio should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no audio file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no audio file is attached, must **NOT** be set if there is an audio file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The audio to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostDatumResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PostDatumResponse>> IngestionIntegrationIdAudioPostWithHttpInfoAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostAudioBodyMeta? meta = default(PostAudioBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Upload chats
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** This endpoint performs the upload of the chat data, image attachments, and file attachments.           The response contains upload responses for the chat data which includes the image attachments            and for the file attachments. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the chat conversation should be uploaded</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="chat"> (optional)</param>
        /// <param name="attachments">The actual attachment files from the chat messages (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostChatResponse</returns>
        System.Threading.Tasks.Task<PostChatResponse> IngestionIntegrationIdChatPostAsync(int id, PostChatConversationBodyMeta? meta = default(PostChatConversationBodyMeta?), PostChatConversationBodyChat? chat = default(PostChatConversationBodyChat?), List<System.IO.Stream>? attachments = default(List<System.IO.Stream>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Upload chats
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** This endpoint performs the upload of the chat data, image attachments, and file attachments.           The response contains upload responses for the chat data which includes the image attachments            and for the file attachments. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the chat conversation should be uploaded</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="chat"> (optional)</param>
        /// <param name="attachments">The actual attachment files from the chat messages (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostChatResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PostChatResponse>> IngestionIntegrationIdChatPostWithHttpInfoAsync(int id, PostChatConversationBodyMeta? meta = default(PostChatConversationBodyMeta?), PostChatConversationBodyChat? chat = default(PostChatConversationBodyChat?), List<System.IO.Stream>? attachments = default(List<System.IO.Stream>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Upload documents
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the document should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The document to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostDatumResponse</returns>
        System.Threading.Tasks.Task<PostDatumResponse> IngestionIntegrationIdDocumentPostAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDocumentBodyMeta? meta = default(PostDocumentBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Upload documents
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the document should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The document to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostDatumResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PostDatumResponse>> IngestionIntegrationIdDocumentPostWithHttpInfoAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDocumentBodyMeta? meta = default(PostDocumentBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Upload emails
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The &#x60;Content-Type&#x60; of the data part must be &#x60;message/rfc822&#x60;. Participant metadata should not be included in the JSON meta payload as it is parsed directly from the attached EML file. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostDatumResponse</returns>
        System.Threading.Tasks.Task<PostDatumResponse> IngestionIntegrationIdEmailPostAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostEmailBodyMeta? meta = default(PostEmailBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Upload emails
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The &#x60;Content-Type&#x60; of the data part must be &#x60;message/rfc822&#x60;. Participant metadata should not be included in the JSON meta payload as it is parsed directly from the attached EML file. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostDatumResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PostDatumResponse>> IngestionIntegrationIdEmailPostWithHttpInfoAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostEmailBodyMeta? meta = default(PostEmailBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Upload other data
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostDatumResponse</returns>
        System.Threading.Tasks.Task<PostDatumResponse> IngestionIntegrationIdOtherPostAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDatumBodyMeta? meta = default(PostDatumBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Upload other data
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostDatumResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PostDatumResponse>> IngestionIntegrationIdOtherPostWithHttpInfoAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDatumBodyMeta? meta = default(PostDatumBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Get integration state
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetIntegrationStateResponse</returns>
        System.Threading.Tasks.Task<GetIntegrationStateResponse> IngestionIntegrationIdStateGetAsync(int id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Get integration state
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetIntegrationStateResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetIntegrationStateResponse>> IngestionIntegrationIdStateGetWithHttpInfoAsync(int id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Update integration state
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:update&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to update</param>
        /// <param name="putIntegrationStateRequest">The integration state to set</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetIntegrationStateResponse</returns>
        System.Threading.Tasks.Task<GetIntegrationStateResponse> IngestionIntegrationIdStatePutAsync(int id, PutIntegrationStateRequest putIntegrationStateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Update integration state
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:update&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to update</param>
        /// <param name="putIntegrationStateRequest">The integration state to set</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetIntegrationStateResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetIntegrationStateResponse>> IngestionIntegrationIdStatePutWithHttpInfoAsync(int id, PutIntegrationStateRequest putIntegrationStateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Upload videos
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the video should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no video file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no video file is attached, must **NOT** be set if there is an video file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The video to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostDatumResponse</returns>
        System.Threading.Tasks.Task<PostDatumResponse> IngestionIntegrationIdVideoPostAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostVideoBodyMeta? meta = default(PostVideoBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Upload videos
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the video should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no video file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no video file is attached, must **NOT** be set if there is an video file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The video to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostDatumResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<PostDatumResponse>> IngestionIntegrationIdVideoPostWithHttpInfoAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostVideoBodyMeta? meta = default(PostVideoBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// Get upload quota
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The quota is for the entire org unit 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">A date in YYYY-MM-DD format that is the start of the time range to summarize in, if not provided the summary starts at the beginning of time (optional)</param>
        /// <param name="to">A date in YYY_MM_DD format that is the end of the time range to summarize, if not provided the summary ends with the current day (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of QuotaResponse</returns>
        System.Threading.Tasks.Task<QuotaResponse> IngestionQuotaGetAsync(string? from = default(string?), string? to = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// Get upload quota
        /// </summary>
        /// <remarks>
        /// **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The quota is for the entire org unit 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">A date in YYYY-MM-DD format that is the start of the time range to summarize in, if not provided the summary starts at the beginning of time (optional)</param>
        /// <param name="to">A date in YYY_MM_DD format that is the end of the time range to summarize, if not provided the summary ends with the current day (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (QuotaResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<QuotaResponse>> IngestionQuotaGetWithHttpInfoAsync(string? from = default(string?), string? to = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IDataIngestionApi : IDataIngestionApiSync, IDataIngestionApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class DataIngestionApi : IDataIngestionApi
    {
        private Org.OpenAPITools.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="DataIngestionApi"/> class.
        /// </summary>
        /// <returns></returns>
        public DataIngestionApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DataIngestionApi"/> class.
        /// </summary>
        /// <returns></returns>
        public DataIngestionApi(string basePath)
        {
            this.Configuration = Org.OpenAPITools.Client.Configuration.MergeConfigurations(
                Org.OpenAPITools.Client.GlobalConfiguration.Instance,
                new Org.OpenAPITools.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DataIngestionApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public DataIngestionApi(Org.OpenAPITools.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Org.OpenAPITools.Client.Configuration.MergeConfigurations(
                Org.OpenAPITools.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DataIngestionApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public DataIngestionApi(Org.OpenAPITools.Client.ISynchronousClient client, Org.OpenAPITools.Client.IAsynchronousClient asyncClient, Org.OpenAPITools.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Org.OpenAPITools.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Org.OpenAPITools.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Org.OpenAPITools.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Org.OpenAPITools.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Check data already exists **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;light&#x60;   **NOTE:** This endpoint supports searching for multiple datums. Because of this behavior it will never return a 404 Not Found, but instead just a blank response array.   Depending on the datum type (audio, chat, document, email, other, or video) different fields are returned. Fields that are always returned are denoted with a &#39;*&#39;.   Only 1 identifier can be specified, if both are specified, only &#x60;identity_data&#x60; will be checked 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identityData">The arbitrary string identifier data associated with the record. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="hashSha256">The sha256 hash of the record to check. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GetDatumIdentityResponse</returns>
        public GetDatumIdentityResponse IngestionExistsGet(List<string>? identityData = default(List<string>?), List<string>? hashSha256 = default(List<string>?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<GetDatumIdentityResponse> localVarResponse = IngestionExistsGetWithHttpInfo(identityData, hashSha256);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check data already exists **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;light&#x60;   **NOTE:** This endpoint supports searching for multiple datums. Because of this behavior it will never return a 404 Not Found, but instead just a blank response array.   Depending on the datum type (audio, chat, document, email, other, or video) different fields are returned. Fields that are always returned are denoted with a &#39;*&#39;.   Only 1 identifier can be specified, if both are specified, only &#x60;identity_data&#x60; will be checked 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identityData">The arbitrary string identifier data associated with the record. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="hashSha256">The sha256 hash of the record to check. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GetDatumIdentityResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<GetDatumIdentityResponse> IngestionExistsGetWithHttpInfo(List<string>? identityData = default(List<string>?), List<string>? hashSha256 = default(List<string>?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (identityData != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("multi", "identity_data", identityData));
            }
            if (hashSha256 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("multi", "hash_sha256", hashSha256));
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionExistsGet";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetDatumIdentityResponse>("/ingestion/exists", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionExistsGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check data already exists **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;light&#x60;   **NOTE:** This endpoint supports searching for multiple datums. Because of this behavior it will never return a 404 Not Found, but instead just a blank response array.   Depending on the datum type (audio, chat, document, email, other, or video) different fields are returned. Fields that are always returned are denoted with a &#39;*&#39;.   Only 1 identifier can be specified, if both are specified, only &#x60;identity_data&#x60; will be checked 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identityData">The arbitrary string identifier data associated with the record. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="hashSha256">The sha256 hash of the record to check. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetDatumIdentityResponse</returns>
        public async System.Threading.Tasks.Task<GetDatumIdentityResponse> IngestionExistsGetAsync(List<string>? identityData = default(List<string>?), List<string>? hashSha256 = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<GetDatumIdentityResponse> localVarResponse = await IngestionExistsGetWithHttpInfoAsync(identityData, hashSha256, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check data already exists **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;light&#x60;   **NOTE:** This endpoint supports searching for multiple datums. Because of this behavior it will never return a 404 Not Found, but instead just a blank response array.   Depending on the datum type (audio, chat, document, email, other, or video) different fields are returned. Fields that are always returned are denoted with a &#39;*&#39;.   Only 1 identifier can be specified, if both are specified, only &#x60;identity_data&#x60; will be checked 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="identityData">The arbitrary string identifier data associated with the record. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="hashSha256">The sha256 hash of the record to check. NOTE: Limit of 20 per request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetDatumIdentityResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<GetDatumIdentityResponse>> IngestionExistsGetWithHttpInfoAsync(List<string>? identityData = default(List<string>?), List<string>? hashSha256 = default(List<string>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (identityData != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("multi", "identity_data", identityData));
            }
            if (hashSha256 != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("multi", "hash_sha256", hashSha256));
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionExistsGet";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<GetDatumIdentityResponse>("/ingestion/exists", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionExistsGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload audio **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the audio should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no audio file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no audio file is attached, must **NOT** be set if there is an audio file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The audio to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostDatumResponse</returns>
        public PostDatumResponse IngestionIntegrationIdAudioPost(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostAudioBodyMeta? meta = default(PostAudioBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> localVarResponse = IngestionIntegrationIdAudioPostWithHttpInfo(id, xThetalakeMetaonly, xThetalakeContentType, meta, data);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload audio **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the audio should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no audio file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no audio file is attached, must **NOT** be set if there is an audio file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The audio to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostDatumResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> IngestionIntegrationIdAudioPostWithHttpInfo(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostAudioBodyMeta? meta = default(PostAudioBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (xThetalakeMetaonly != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Metaonly", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeMetaonly)); // header parameter
            }
            if (xThetalakeContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Content-Type", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeContentType)); // header parameter
            }
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", localVarMultipartFormData ? Org.OpenAPITools.Client.ClientUtils.ParameterToString(meta) : Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdAudioPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PostDatumResponse>("/ingestion/integration/{id}/audio", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdAudioPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload audio **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the audio should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no audio file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no audio file is attached, must **NOT** be set if there is an audio file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The audio to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostDatumResponse</returns>
        public async System.Threading.Tasks.Task<PostDatumResponse> IngestionIntegrationIdAudioPostAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostAudioBodyMeta? meta = default(PostAudioBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> localVarResponse = await IngestionIntegrationIdAudioPostWithHttpInfoAsync(id, xThetalakeMetaonly, xThetalakeContentType, meta, data, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload audio **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the audio should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no audio file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no audio file is attached, must **NOT** be set if there is an audio file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The audio to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostDatumResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PostDatumResponse>> IngestionIntegrationIdAudioPostWithHttpInfoAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostAudioBodyMeta? meta = default(PostAudioBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (xThetalakeMetaonly != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Metaonly", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeMetaonly)); // header parameter
            }
            if (xThetalakeContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Content-Type", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeContentType)); // header parameter
            }
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdAudioPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PostDatumResponse>("/ingestion/integration/{id}/audio", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdAudioPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload chats **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** This endpoint performs the upload of the chat data, image attachments, and file attachments.           The response contains upload responses for the chat data which includes the image attachments            and for the file attachments. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the chat conversation should be uploaded</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="chat"> (optional)</param>
        /// <param name="attachments">The actual attachment files from the chat messages (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostChatResponse</returns>
        public PostChatResponse IngestionIntegrationIdChatPost(int id, PostChatConversationBodyMeta? meta = default(PostChatConversationBodyMeta?), PostChatConversationBodyChat? chat = default(PostChatConversationBodyChat?), List<System.IO.Stream>? attachments = default(List<System.IO.Stream>?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PostChatResponse> localVarResponse = IngestionIntegrationIdChatPostWithHttpInfo(id, meta, chat, attachments);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload chats **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** This endpoint performs the upload of the chat data, image attachments, and file attachments.           The response contains upload responses for the chat data which includes the image attachments            and for the file attachments. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the chat conversation should be uploaded</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="chat"> (optional)</param>
        /// <param name="attachments">The actual attachment files from the chat messages (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostChatResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<PostChatResponse> IngestionIntegrationIdChatPostWithHttpInfo(int id, PostChatConversationBodyMeta? meta = default(PostChatConversationBodyMeta?), PostChatConversationBodyChat? chat = default(PostChatConversationBodyChat?), List<System.IO.Stream>? attachments = default(List<System.IO.Stream>?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", localVarMultipartFormData ? Org.OpenAPITools.Client.ClientUtils.ParameterToString(meta) : Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (chat != null)
            {
                localVarRequestOptions.FormParameters.Add("chat", localVarMultipartFormData ? Org.OpenAPITools.Client.ClientUtils.ParameterToString(chat) : Org.OpenAPITools.Client.ClientUtils.Serialize(chat)); // form parameter
            }
            if (attachments != null)
            {
                foreach (var file in attachments)
                {
                    localVarRequestOptions.FileParameters.Add("attachments", file);
                }
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdChatPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PostChatResponse>("/ingestion/integration/{id}/chat", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdChatPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload chats **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** This endpoint performs the upload of the chat data, image attachments, and file attachments.           The response contains upload responses for the chat data which includes the image attachments            and for the file attachments. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the chat conversation should be uploaded</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="chat"> (optional)</param>
        /// <param name="attachments">The actual attachment files from the chat messages (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostChatResponse</returns>
        public async System.Threading.Tasks.Task<PostChatResponse> IngestionIntegrationIdChatPostAsync(int id, PostChatConversationBodyMeta? meta = default(PostChatConversationBodyMeta?), PostChatConversationBodyChat? chat = default(PostChatConversationBodyChat?), List<System.IO.Stream>? attachments = default(List<System.IO.Stream>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PostChatResponse> localVarResponse = await IngestionIntegrationIdChatPostWithHttpInfoAsync(id, meta, chat, attachments, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload chats **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** This endpoint performs the upload of the chat data, image attachments, and file attachments.           The response contains upload responses for the chat data which includes the image attachments            and for the file attachments. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the chat conversation should be uploaded</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="chat"> (optional)</param>
        /// <param name="attachments">The actual attachment files from the chat messages (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostChatResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PostChatResponse>> IngestionIntegrationIdChatPostWithHttpInfoAsync(int id, PostChatConversationBodyMeta? meta = default(PostChatConversationBodyMeta?), PostChatConversationBodyChat? chat = default(PostChatConversationBodyChat?), List<System.IO.Stream>? attachments = default(List<System.IO.Stream>?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (chat != null)
            {
                localVarRequestOptions.FormParameters.Add("chat", Org.OpenAPITools.Client.ClientUtils.Serialize(chat)); // form parameter
            }
            if (attachments != null)
            {
                foreach (var file in attachments)
                {
                    localVarRequestOptions.FileParameters.Add("attachments", file);
                }
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdChatPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PostChatResponse>("/ingestion/integration/{id}/chat", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdChatPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload documents **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the document should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The document to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostDatumResponse</returns>
        public PostDatumResponse IngestionIntegrationIdDocumentPost(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDocumentBodyMeta? meta = default(PostDocumentBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> localVarResponse = IngestionIntegrationIdDocumentPostWithHttpInfo(id, xThetalakeMetaonly, xThetalakeContentType, meta, data);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload documents **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the document should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The document to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostDatumResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> IngestionIntegrationIdDocumentPostWithHttpInfo(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDocumentBodyMeta? meta = default(PostDocumentBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (xThetalakeMetaonly != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Metaonly", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeMetaonly)); // header parameter
            }
            if (xThetalakeContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Content-Type", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeContentType)); // header parameter
            }
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", localVarMultipartFormData ? Org.OpenAPITools.Client.ClientUtils.ParameterToString(meta) : Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdDocumentPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PostDatumResponse>("/ingestion/integration/{id}/document", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdDocumentPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload documents **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the document should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The document to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostDatumResponse</returns>
        public async System.Threading.Tasks.Task<PostDatumResponse> IngestionIntegrationIdDocumentPostAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDocumentBodyMeta? meta = default(PostDocumentBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> localVarResponse = await IngestionIntegrationIdDocumentPostWithHttpInfoAsync(id, xThetalakeMetaonly, xThetalakeContentType, meta, data, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload documents **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the document should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The document to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostDatumResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PostDatumResponse>> IngestionIntegrationIdDocumentPostWithHttpInfoAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDocumentBodyMeta? meta = default(PostDocumentBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (xThetalakeMetaonly != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Metaonly", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeMetaonly)); // header parameter
            }
            if (xThetalakeContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Content-Type", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeContentType)); // header parameter
            }
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdDocumentPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PostDatumResponse>("/ingestion/integration/{id}/document", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdDocumentPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload emails **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The &#x60;Content-Type&#x60; of the data part must be &#x60;message/rfc822&#x60;. Participant metadata should not be included in the JSON meta payload as it is parsed directly from the attached EML file. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostDatumResponse</returns>
        public PostDatumResponse IngestionIntegrationIdEmailPost(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostEmailBodyMeta? meta = default(PostEmailBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> localVarResponse = IngestionIntegrationIdEmailPostWithHttpInfo(id, xThetalakeMetaonly, xThetalakeContentType, meta, data);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload emails **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The &#x60;Content-Type&#x60; of the data part must be &#x60;message/rfc822&#x60;. Participant metadata should not be included in the JSON meta payload as it is parsed directly from the attached EML file. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostDatumResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> IngestionIntegrationIdEmailPostWithHttpInfo(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostEmailBodyMeta? meta = default(PostEmailBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (xThetalakeMetaonly != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Metaonly", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeMetaonly)); // header parameter
            }
            if (xThetalakeContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Content-Type", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeContentType)); // header parameter
            }
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", localVarMultipartFormData ? Org.OpenAPITools.Client.ClientUtils.ParameterToString(meta) : Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdEmailPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PostDatumResponse>("/ingestion/integration/{id}/email", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdEmailPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload emails **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The &#x60;Content-Type&#x60; of the data part must be &#x60;message/rfc822&#x60;. Participant metadata should not be included in the JSON meta payload as it is parsed directly from the attached EML file. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostDatumResponse</returns>
        public async System.Threading.Tasks.Task<PostDatumResponse> IngestionIntegrationIdEmailPostAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostEmailBodyMeta? meta = default(PostEmailBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> localVarResponse = await IngestionIntegrationIdEmailPostWithHttpInfoAsync(id, xThetalakeMetaonly, xThetalakeContentType, meta, data, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload emails **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The &#x60;Content-Type&#x60; of the data part must be &#x60;message/rfc822&#x60;. Participant metadata should not be included in the JSON meta payload as it is parsed directly from the attached EML file. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostDatumResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PostDatumResponse>> IngestionIntegrationIdEmailPostWithHttpInfoAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostEmailBodyMeta? meta = default(PostEmailBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (xThetalakeMetaonly != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Metaonly", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeMetaonly)); // header parameter
            }
            if (xThetalakeContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Content-Type", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeContentType)); // header parameter
            }
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdEmailPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PostDatumResponse>("/ingestion/integration/{id}/email", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdEmailPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload other data **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostDatumResponse</returns>
        public PostDatumResponse IngestionIntegrationIdOtherPost(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDatumBodyMeta? meta = default(PostDatumBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> localVarResponse = IngestionIntegrationIdOtherPostWithHttpInfo(id, xThetalakeMetaonly, xThetalakeContentType, meta, data);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload other data **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostDatumResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> IngestionIntegrationIdOtherPostWithHttpInfo(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDatumBodyMeta? meta = default(PostDatumBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (xThetalakeMetaonly != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Metaonly", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeMetaonly)); // header parameter
            }
            if (xThetalakeContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Content-Type", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeContentType)); // header parameter
            }
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", localVarMultipartFormData ? Org.OpenAPITools.Client.ClientUtils.ParameterToString(meta) : Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdOtherPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PostDatumResponse>("/ingestion/integration/{id}/other", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdOtherPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload other data **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostDatumResponse</returns>
        public async System.Threading.Tasks.Task<PostDatumResponse> IngestionIntegrationIdOtherPostAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDatumBodyMeta? meta = default(PostDatumBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> localVarResponse = await IngestionIntegrationIdOtherPostWithHttpInfoAsync(id, xThetalakeMetaonly, xThetalakeContentType, meta, data, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload other data **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the data should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no data file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no data file is attached, must **NOT** be set if there is a data file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The file to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostDatumResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PostDatumResponse>> IngestionIntegrationIdOtherPostWithHttpInfoAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostDatumBodyMeta? meta = default(PostDatumBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (xThetalakeMetaonly != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Metaonly", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeMetaonly)); // header parameter
            }
            if (xThetalakeContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Content-Type", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeContentType)); // header parameter
            }
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdOtherPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PostDatumResponse>("/ingestion/integration/{id}/other", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdOtherPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get integration state **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GetIntegrationStateResponse</returns>
        public GetIntegrationStateResponse IngestionIntegrationIdStateGet(int id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<GetIntegrationStateResponse> localVarResponse = IngestionIntegrationIdStateGetWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get integration state **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GetIntegrationStateResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<GetIntegrationStateResponse> IngestionIntegrationIdStateGetWithHttpInfo(int id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdStateGet";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetIntegrationStateResponse>("/ingestion/integration/{id}/state", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdStateGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get integration state **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetIntegrationStateResponse</returns>
        public async System.Threading.Tasks.Task<GetIntegrationStateResponse> IngestionIntegrationIdStateGetAsync(int id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<GetIntegrationStateResponse> localVarResponse = await IngestionIntegrationIdStateGetWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get integration state **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetIntegrationStateResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<GetIntegrationStateResponse>> IngestionIntegrationIdStateGetWithHttpInfoAsync(int id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdStateGet";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<GetIntegrationStateResponse>("/ingestion/integration/{id}/state", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdStateGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update integration state **REQUIRED PERMISSION:** &#x60;ingestion:update&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to update</param>
        /// <param name="putIntegrationStateRequest">The integration state to set</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GetIntegrationStateResponse</returns>
        public GetIntegrationStateResponse IngestionIntegrationIdStatePut(int id, PutIntegrationStateRequest putIntegrationStateRequest, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<GetIntegrationStateResponse> localVarResponse = IngestionIntegrationIdStatePutWithHttpInfo(id, putIntegrationStateRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update integration state **REQUIRED PERMISSION:** &#x60;ingestion:update&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to update</param>
        /// <param name="putIntegrationStateRequest">The integration state to set</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GetIntegrationStateResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<GetIntegrationStateResponse> IngestionIntegrationIdStatePutWithHttpInfo(int id, PutIntegrationStateRequest putIntegrationStateRequest, int operationIndex = 0)
        {
            // verify the required parameter 'putIntegrationStateRequest' is set
            if (putIntegrationStateRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'putIntegrationStateRequest' when calling DataIngestionApi->IngestionIntegrationIdStatePut");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = putIntegrationStateRequest;

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdStatePut";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<GetIntegrationStateResponse>("/ingestion/integration/{id}/state", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdStatePut", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update integration state **REQUIRED PERMISSION:** &#x60;ingestion:update&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to update</param>
        /// <param name="putIntegrationStateRequest">The integration state to set</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetIntegrationStateResponse</returns>
        public async System.Threading.Tasks.Task<GetIntegrationStateResponse> IngestionIntegrationIdStatePutAsync(int id, PutIntegrationStateRequest putIntegrationStateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<GetIntegrationStateResponse> localVarResponse = await IngestionIntegrationIdStatePutWithHttpInfoAsync(id, putIntegrationStateRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update integration state **REQUIRED PERMISSION:** &#x60;ingestion:update&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration state to update</param>
        /// <param name="putIntegrationStateRequest">The integration state to set</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetIntegrationStateResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<GetIntegrationStateResponse>> IngestionIntegrationIdStatePutWithHttpInfoAsync(int id, PutIntegrationStateRequest putIntegrationStateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'putIntegrationStateRequest' is set
            if (putIntegrationStateRequest == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'putIntegrationStateRequest' when calling DataIngestionApi->IngestionIntegrationIdStatePut");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = putIntegrationStateRequest;

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdStatePut";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<GetIntegrationStateResponse>("/ingestion/integration/{id}/state", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdStatePut", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload videos **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the video should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no video file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no video file is attached, must **NOT** be set if there is an video file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The video to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PostDatumResponse</returns>
        public PostDatumResponse IngestionIntegrationIdVideoPost(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostVideoBodyMeta? meta = default(PostVideoBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> localVarResponse = IngestionIntegrationIdVideoPostWithHttpInfo(id, xThetalakeMetaonly, xThetalakeContentType, meta, data);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload videos **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the video should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no video file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no video file is attached, must **NOT** be set if there is an video file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The video to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PostDatumResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> IngestionIntegrationIdVideoPostWithHttpInfo(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostVideoBodyMeta? meta = default(PostVideoBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (xThetalakeMetaonly != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Metaonly", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeMetaonly)); // header parameter
            }
            if (xThetalakeContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Content-Type", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeContentType)); // header parameter
            }
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", localVarMultipartFormData ? Org.OpenAPITools.Client.ClientUtils.ParameterToString(meta) : Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdVideoPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PostDatumResponse>("/ingestion/integration/{id}/video", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdVideoPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload videos **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the video should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no video file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no video file is attached, must **NOT** be set if there is an video file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The video to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PostDatumResponse</returns>
        public async System.Threading.Tasks.Task<PostDatumResponse> IngestionIntegrationIdVideoPostAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostVideoBodyMeta? meta = default(PostVideoBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PostDatumResponse> localVarResponse = await IngestionIntegrationIdVideoPostWithHttpInfoAsync(id, xThetalakeMetaonly, xThetalakeContentType, meta, data, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload videos **REQUIRED PERMISSION:** &#x60;ingestion:upload&#x60;   **RATE LIMIT:** &#x60;heavy&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the integration to which the video should be uploaded</param>
        /// <param name="xThetalakeMetaonly">Must be set true if no video file is attached (optional)</param>
        /// <param name="xThetalakeContentType">The content type using standard [MIME types](https://www.iana.org/assignments/media-types/media-types.xhtml). Must be set if no video file is attached, must **NOT** be set if there is an video file attached (optional)</param>
        /// <param name="meta"> (optional)</param>
        /// <param name="data">The video to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PostDatumResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PostDatumResponse>> IngestionIntegrationIdVideoPostWithHttpInfoAsync(int id, bool? xThetalakeMetaonly = default(bool?), string? xThetalakeContentType = default(string?), PostVideoBodyMeta? meta = default(PostVideoBodyMeta?), System.IO.Stream? data = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (xThetalakeMetaonly != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Metaonly", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeMetaonly)); // header parameter
            }
            if (xThetalakeContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Thetalake-Content-Type", Org.OpenAPITools.Client.ClientUtils.ParameterToString(xThetalakeContentType)); // header parameter
            }
            if (meta != null)
            {
                localVarRequestOptions.FormParameters.Add("meta", Org.OpenAPITools.Client.ClientUtils.Serialize(meta)); // form parameter
            }
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionIntegrationIdVideoPost";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PostDatumResponse>("/ingestion/integration/{id}/video", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionIntegrationIdVideoPost", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get upload quota **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The quota is for the entire org unit 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">A date in YYYY-MM-DD format that is the start of the time range to summarize in, if not provided the summary starts at the beginning of time (optional)</param>
        /// <param name="to">A date in YYY_MM_DD format that is the end of the time range to summarize, if not provided the summary ends with the current day (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>QuotaResponse</returns>
        public QuotaResponse IngestionQuotaGet(string? from = default(string?), string? to = default(string?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<QuotaResponse> localVarResponse = IngestionQuotaGetWithHttpInfo(from, to);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get upload quota **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The quota is for the entire org unit 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">A date in YYYY-MM-DD format that is the start of the time range to summarize in, if not provided the summary starts at the beginning of time (optional)</param>
        /// <param name="to">A date in YYY_MM_DD format that is the end of the time range to summarize, if not provided the summary ends with the current day (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of QuotaResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<QuotaResponse> IngestionQuotaGetWithHttpInfo(string? from = default(string?), string? to = default(string?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            var localVarMultipartFormData = localVarContentType == "multipart/form-data";
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "to", to));
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionQuotaGet";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<QuotaResponse>("/ingestion/quota", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionQuotaGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get upload quota **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The quota is for the entire org unit 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">A date in YYYY-MM-DD format that is the start of the time range to summarize in, if not provided the summary starts at the beginning of time (optional)</param>
        /// <param name="to">A date in YYY_MM_DD format that is the end of the time range to summarize, if not provided the summary ends with the current day (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of QuotaResponse</returns>
        public async System.Threading.Tasks.Task<QuotaResponse> IngestionQuotaGetAsync(string? from = default(string?), string? to = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<QuotaResponse> localVarResponse = await IngestionQuotaGetWithHttpInfoAsync(from, to, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get upload quota **REQUIRED PERMISSION:** &#x60;ingestion:read&#x60;   **RATE LIMIT:** &#x60;heavy&#x60;   **NOTE:** The quota is for the entire org unit 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">A date in YYYY-MM-DD format that is the start of the time range to summarize in, if not provided the summary starts at the beginning of time (optional)</param>
        /// <param name="to">A date in YYY_MM_DD format that is the end of the time range to summarize, if not provided the summary ends with the current day (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (QuotaResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<QuotaResponse>> IngestionQuotaGetWithHttpInfoAsync(string? from = default(string?), string? to = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "to", to));
            }

            localVarRequestOptions.Operation = "DataIngestionApi.IngestionQuotaGet";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (ClientCredentials) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (BearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<QuotaResponse>("/ingestion/quota", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IngestionQuotaGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
